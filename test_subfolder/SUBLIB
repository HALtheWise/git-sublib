#!/usr/bin/env python

from __future__ import print_function
import sys
import subprocess
import os
import os.path
import tempfile

UPSTREAM_URL = None
UPSTREAM_BRANCH = None
UPSTREAM_LAST_MERGED_COMMIT = None
LOCAL_LAST_MERGE_PARENT = None

USAGE = """
USAGE
"""


def main():
    if len(sys.argv) < 2:
        print(USAGE)
        return

    command = sys.argv[1]
    print('Command: {}'.format(command))

    if command == 'clone':
        if len(sys.argv) < 3:
            print(USAGE)
            return
        clone(sys.argv[2])
    elif command == 'pull':
        pull()
    elif command == 'push':
        raise NotImplementedError("")
    else:
        print(USAGE)


def pull():
    make_merging_repo()


def clone(src_branch):
    """Performs a git read-tree operation and records evidence of what it did"""
    # TODO: check that the directory is empty except for this file
    # TODO: check that the index is clean
    # TODO: check that this file is in the right directory
    local_hash = call('git rev-parse HEAD')
    remote_hash = call('git rev-parse {}'.format(src_branch))

    prefix = get_prefix()

    call('git read-tree -u --prefix {p} {h}'.format(p=prefix, h=remote_hash))

    with open(os.path.join(os.curdir, 'SUBLIB'), 'a') as thisfile:
        store_config({
            'UPSTREAM_URL': None,
            'UPSTREAM_BRANCH': src_branch,
            'UPSTREAM_LAST_MERGED_COMMIT': remote_hash,
            'LOCAL_LAST_MERGE_PARENT': local_hash,
        })

    call('git add .')

    print('Files from {} cloned into the current directory, commit to finalize')


def store_config(args):
    # TODO: add new args correctly as well
    with open(os.path.join(os.curdir, 'SUBLIB'), 'r') as oldfile:
        lines = oldfile.readlines()

    for i, line in enumerate(lines):
        if line.split():
            varname = line.split()[0]
            if varname in args:
                lines[i] = "{ARG} = {val}\n".format(
                    ARG=varname, val=args[varname].__repr__())

    with open(os.path.join(os.curdir, 'SUBLIB'), 'w') as newfile:
        newfile.writelines(lines)


def get_prefix():
    repo_root = call('git rev-parse --show-toplevel')
    return os.path.relpath(os.curdir, start=repo_root)


def call(cmd, cwd=None):
    print(cmd)
    if type(cmd) == str:
        cmd = cmd.split()
    output = subprocess.check_output(cmd, cwd=cwd).decode('utf-8').strip()
    print("-- {}".format(output))
    return output


def make_merging_repo():
    temp_repo = tempfile.mkdtemp(prefix='sublib_temp_')
    print(temp_repo)

    call('git init', cwd=temp_repo)


if __name__ == '__main__':
    main()


# def merge_remote_changes():
#     head = call('git rev-parse HEAD')
#     merge_base_local = get_merge_base_local()
#     print(f'Merge base: {merge_base_local}')

#     # Switch to the parent of the last merge
#     call(f'git checkout {LOCAL_LAST_MERGE_PARENT}')

#     # Set the index to hold the result of the last merge
#     call(f'git read-tree -um {merge_base_local}')

#     # Make a merge commit for the last merge
#     tree_hash = call('git write-tree')
#     created_base_hash = call(
#         f'git commit-tree -p {LOCAL_LAST_MERGE_PARENT} -p {REMOTE_LAST_MERGED_COMMIT} {tree_hash} -m "Helloworld"')

#     call(f'git checkout {created_base_hash}')

#     # Cherry-pick the changes from local into the new simulated branch
#     call(f'git cherry-pick {merge_base_local}..{head}')

#     # Do the merge
